ifdef::backend-pdf[]
= Open Energy Management System
endif::[]
ifndef::backend-pdf[]
= image:OpenEMS-Logo.png[the Feneco - OpenEMS Logo,400,role="related right"]  Open Energy Management System
endif::[]
Stefan Feilmeier (c) 2018 FENECON GmbH
Version 2018.9.0
:sectnums:
:sectnumlevels: 4
:toc:
:toclevels: 4
:experimental:
:keywords: AsciiDoc
:source-highlighter: highlight.js
:icons: font
:imagesdir: ./img
:title-logo-image: image:OpenEMS-Logo.png[pdfwidth=4.25in,align=center]

== Introduction

OpenEMS is a modular platform for energy management applications.
It was developed around the requirements of controlling, monitoring and integrating energy storage systems together with renewable energy sources and complementary devices and services.

=== OpenEMS IoT stack

The OpenEMS 'Internet of Things' stack contains three main components:

 * **OpenEMS Edge** runs on-site and actually controls the devices
 * **OpenEMS UI** is the generic user interface
 * **OpenEMS Backend** runs on a (cloud) server, connects the decentralized Edge systems and provides aggregation, monitoring and control via internet

=== Features

The OpenEMS software architecture was designed to leverage some features that are required by a modern and flexible Energy Management System:

 * Fast, PLC-like control of battery inverters and other devices
 * Easily extendable due to the use of modern programming languages and modular architecture
 * Wide range of supported devices - (battery) inverters, meters, etc. - and protocols
 * Modern web-based real-time user interface

.Screenshots of OpenEMS UI
image::ui-screenshots.png[Screenshots of OpenEMS UI]
.Screenshots of OpenEMS UI
image::ui-screenshots2.png[Screenshots of OpenEMS UI]

=== Open Source philosophy

OpenEMS development was started by https://www.fenecon.de[FENECON GmbH icon:external-link[]], a German company specialized in manufacturing and project development of energy storage systems. It is the software stack behind https://fenecon.de/page/fems[FEMS - FENECON Energy Management System icon:external-link[]] and widely used in private, commercial and industrial applications.

We are inviting third parties - like universities, hardware manufacturers, software companies, commercial and private owners,... - to use OpenEMS for their own projects and are glad to support them with their first steps. In any case if you are interested in OpenEMS our development team would be glad to hear from you at fems@fenecon.de.

OpenEMS is funded by several federal and EU funding projects. If you are a developer and you would like to get hired by one of the partner companies or universities for working on OpenEMS, please send your motivation letter to fems@fenecon.de.

=== License

* OpenEMS Edge 
* OpenEMS Backend

Copyright (C) 2016-2018 FENECON GmbH.

This product includes software developed at FENECON GmbH: you can
redistribute it and/or modify it under the terms of the [Eclipse Public License version 2.0](LICENSE-EPL-2.0). 

 * OpenEMS UI

Copyright (C) 2016-2018 FENECON GmbH.

This product includes software developed at FENECON GmbH: you can
redistribute it and/or modify it under the terms of the [GNU Affero General Public License version 3](LICENSE-AGPL-3.0).

=== Development guidelines

Development follows the https://de.wikipedia.org/wiki/Agile_Softwareentwicklung[Agile Manifesto icon:external-link[]] and is driven by the https://de.wikipedia.org/wiki/Scrum[Scrum icon:external-link[]] methodology. 
The source code is available online at http://openems.io and on https://github.com/OpenEMS/openems[GitHub icon:github[]]. 
New versions are released after every Scrum Sprint and https://github.com/OpenEMS/openems/releases[tagged icon:github[]] accordingly. 
Version numbers are built using the pattern `year.number of sprint`, e.g. version `2018.4` is the result of the fourth sprint in 2018. 
Git development follows the https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow[Gitflow Workflow], so the https://github.com/OpenEMS/openems/tree/master/[master branch icon:github[]] always holds the stable release, while active development is happening on the https://github.com/OpenEMS/openems/tree/develop[develop branch icon:github[]] or in separate feature branches.

For Edge and Backend Java development we recommend the https://www.eclipse.org/ide/[Eclipse IDE icon:external-link[]].
For the UI (TypeScript + Angular.io) we recommend https://code.visualstudio.com/[Visual Studio Code icon:external-link[]]. 
The documentation is generated using http://asciidoc.org[AsciiDoc icon:external-link[]]. 
For handling git we recommend https://www.sourcetreeapp.com/[Sourctree by Atlassian icon:external-link[]].

// TODO remove this after migration to OSGi is finished
=== Migration to OSGi

Starting with version https://github.com/OpenEMS/openems/releases/tag/2018.7[2018.7 icon:github[]] OpenEMS Edge is getting migrated to https://en.wikipedia.org/wiki/OSGi[OSGi icon:external-link[]], a platform to provide a completely modular and dynamic service oriented system. Certain parts of Edge are not yet migrated and for the time being only available in the deprecated https://github.com/OpenEMS/openems/tree/old_master[old_master branch icon:github[]].

=== System architecture

OpenEMS is generally used in combination with external hardware and software components
(the exception is a simulated development environment - see https://github.com/OpenEMS/openems/blob/old_master/README.md#get-started[Getting Started])
As a brief overview, this is how OpenEMS is used in production setups:

.OpenEMS system architecture
image::system-architecture.png[OpenEMS system architecture]

== Getting Started

This quick 'Getting Started' should help you setup up a complete development environment. On finishing you will have a working instance of OpenEMS Edge, with simulated energy storage and photovoltaic system, as well as an OpenEMS UI for monitoring the simulator inside your web browser.

=== Download the source code

. Download any https://git-scm.com[git client icon:external-link[]] and install it. Our recommendation is https://www.sourcetreeapp.com/[Sourctree by Atlassian icon:external-link[]]

. Clone the OpenEMS git repository

.. In Sourcetree:

... press btn:[File] -> btn:[Clone]
... enter the git repository path `https://github.com/OpenEMS/openems.git`
... select a target directory, for example `C:\Users\your.user\git\openems`
... open btn:[Advanced Settings]
... select the branch btn:[develop]
... and press btn:[Clone].
+
.Cloning the git repository using Sourcetree
image::sourcetree.png[Cloning the git repository using Sourcetree]

.. Alternatively: with the git command line utility

... open a console
... change to the target directory
... execute `git clone https://github.com/OpenEMS/openems.git --branch develop`

. Git is downloading the complete source code for you.

=== Setup Eclipse IDE for OpenEMS Edge and Backend

. Prepare Eclipse IDE
.. Download http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html[Java SE Development Kit 8 icon:external-link[]] and install it
.. Download https://www.eclipse.org[Eclipse for Java icon:external-link[]], install and start it
.. On first start you will get asked to create a workspace.
Select a directory - for example `C:\Users\your.user\git\openems-workspace` - and press btn:[Lauch]. _The directory needs to be different from your source code directory selected above._
+
.Creating a workspace in Eclipse IDE
image::eclipse-workspace.png[Creating a workspace in Eclipse IDE]

.. Install http://bndtools.org[BndTools icon:external-link[]] in Eclipse:
+
Menu: btn:[Help] →  btn:[Eclipse Marketplace...] → btn:[Find:] → enter btn:[Bndtools] → press btn:[Install]

. Import OpenEMS component projects (OSGi bundles):
+
Menu: btn:[File] →  btn:[Import...] → btn:[Bndtools] → btn:[Existing Bnd Workspace] → Root directory: btn:[Browse...] → select the directory with the source code - for example `C:\Users\your.user\git\openems` → btn:[OK] → btn:[Finish] → "Switch to Bndtools perspective?" btn:[yes] 

. Eclipse should have successfully built OpenEMS Edge and Backend, showing no entry in Problems.
+
.Eclipse IDE showing 'no problems'
image::eclipse-no-problems.png[Eclipse IDE showing 'no problems']

=== Run OpenEMS Edge and start Simulator

. Run OpenEMS Edge
.. In Eclipse IDE open the project btn:[io.openems.edge.application] and double click on btn:[EdgeApp.run].
+
.io.openems.edge.application project in Eclipse IDE
image::eclipse-io.openems.edge.application.png[io.openems.edge.application project in Eclipse IDE]

.. Click on btn:[Run OSGi] to run OpenEMS Edge. You should see log outputs on the console inside Eclipse IDE.
+
.OpenEMS Edge initial log output
image::eclipse-edge-initial-log-output.png[OpenEMS Edge initial log output]

. Configure and start the Simulator
.. Open the http://localhost:8080/system/console/configMgr[Apache Felix Web Console Configuration icon:external-link[]].
+
Login with username *admin* and password *admin*.
+
.Apache Felix Web Console Configuration
image::apache-felix-console-configuration.png[Apache Felix Web Console Configuration]

.. Configure a Scheduler
+
NOTE: The Scheduler is responsible for executing the control algorithms (Controllers) and defines the OpenEMS Edge application cycle
// TODO: link to Scheduler description

... Click on "Scheduler All Alphabetically"
+
.Configuration of All Alphabetically Scheduler
image::config-scheduler-all-alphabetically.png[Configuration of All Alphabetically Scheduler]

... Accept the default values and click btn:[Save]

... You created your first instance of an OpenEMS Component with ID "scheduler0". The log shows:
+
`INFO  [onent.AbstractOpenemsComponent] [scheduler0] Activate AllAlphabetically [edge.scheduler.allalphabetically]`
+
Add any other OpenEMS Components in the same way:

.. Configure debug outputs on the console: "Controller Debug Log". The default values can be accepted without changes.
+
.Configuration of Controller Debug Log
image::config-controller-debug-log.png[Configuration of Controller Debug Log]
+
The log shows:
+
`INFO  [onent.AbstractOpenemsComponent] [ctrlDebugLog0] Activate DebugLog [edge.controller.debuglog]`,
+
followed once per second by
+
`INFO  [e.controller.debuglog.DebugLog] [ctrlDebugLog0] _sum[Ess SoC:0 %|L:0 W Grid L:0 W Production L:0 W Consumption L:0 W]`.
+
NOTE: It is once per second because you accepted the default value of "1000 ms" for "Cycle time" in the Scheduler configuration.

.. Configure the standard-load-profile datasource using the according input file in the csv-reader: "Simulator DataSource: CSVReader". The default values can be accepted without changes. The "Source" value is already set to the right input file.
+
.Configuration of Simulator DataSource: CSVReader as standard load profile datasource
image::config-simulator-datasource-standard-load-profile.png[Configuration of Simulator DataSource: CSVReader as standard load profile datasource]
+
The log shows:
+
`INFO  [onent.AbstractOpenemsComponent] [datasource0] Activate CSVDatasource [edge.simulator.datasource.csv]`,
+
NOTE: The data source was configured with the OpenEMS Component ID "datasource0" which will be used in the next step as reference.

.. Configure a simulated grid meter: "Simulator GridMeter Acting". Configure the Datasource-ID "datasource0" to refer to the data source configured above.
+
.Configuration of Simulator GridMeter Acting
image::config-simulator-grid-meter-acting.png[Configuration of Simulator GridMeter Acting]
+
This time some more logs will show up. Most importantly they show, that the Grid meter now shows a power value.
+
----
INFO  [onent.AbstractOpenemsComponent] [meter0] Activate GridMeter [edge.simulator.meter.grid.acting]
[onent.AbstractOpenemsComponent] [meter0] Deactivate GridMeter [edge.simulator.meter.grid.acting]
[onent.AbstractOpenemsComponent] [meter0] Activate GridMeter [edge.simulator.meter.grid.acting]
[e.controller.debuglog.DebugLog] [ctrlDebugLog0] _sum[Ess SoC:0 %|L:0 W Grid L:1423 W Production L:0 W Consumption L:1423 W] meter0[1423 W] 
----
+
NOTE: This setup causes the simulated grid-meter to take the standardized load-profiles data as input parameter.
+
NOTE: 'Acting' referrs to the fact, that this meter actively provides data - in opposite to a 'Reacting' device that is reacting on other components: for example the 'Simulator.EssSymmetric.Reacting' configured below.

.. Configure a simulated reacting energy storage system: "Simulator EssSymmetric Reacting". The default values can be accepted without changes.
+
.Configuration of Simulator EssSymmetric Reacting
image::config-simulator-esssymmetric-reacting.png[Configuration of Simulator EssSymmetric Reacting]
+
The log shows:
+
`INFO  [e.controller.debuglog.DebugLog] [ctrlDebugLog0] _sum[Ess SoC:50 %|L:0 W Grid L:864 W Production L:0 W Consumption L:864 W] ess0[SoC:50 %|L:0 W|OnGrid] meter0[864 W]`
+
Note, that the DebugLog now shows data for the battery, but the charge/discharge power stays at "0 W" and the state of charge stays at "50 %" as configured. Next step is to configure a control algorithm that tells the battery to charge or discharge.

.. Configure the self-consumption optimization algorithm: "Controller Balancing Symmetric". Configure the Ess-ID "ess0" and Grid-Meter-ID "meter0" to refer to the components configured above.
+
.Configuration of Symmetric Balancing Controller
image::config-controller-balancing-symmetric.png[Configuration of Symmetric Balancing Controller]
+
The log shows:
+
`INFO  [e.controller.debuglog.DebugLog] [ctrlDebugLog0] _sum[Ess SoC:49 %|L:1167 W Grid L:-39 W Production L:0 W Consumption L:1128 W] ess0[SoC:49 %|L:1167 W|OnGrid] meter0[-39 W]`
+
NOTE: Note, how the Controller now tells the battery to discharge (`Ess SoC:49 %|L:1167 W`), trying to balance the Grid power to "0 W" (`Grid L:-39 W`):

.. Configure the websocket Api Controller: "Controller Api Websocket". The default values can be accepted without changes.
+
.Configuration of Controller Api Websocket
image::config-controller-api-websocket.png[Configuration of Controller Api Websocket]
+
The log shows:
+
----
INFO  [onent.AbstractOpenemsComponent] [ctrlApiWebsocket0] Activate WebsocketApi [edge.controller.api.websocket]
INFO  [ler.api.websocket.WebsocketApi] [ctrlApiWebsocket0] Websocket-Api started on port [8085].
----
+
NOTE: The Controller Api Websocket is required to enable access to OpenEMS Edge by a local OpenEMS UI.

=== Setup Visual Studio Code for OpenEMS UI

. Download https://nodejs.org[node.js LTS icon:external-link[]] and install it.
. Download https://code.visualstudio.com/[Visual Studio Code icon:external-link[]], install and start it.
. Open OpenEMS UI source code in Visual Studio Code:
+
Menu: btn:[File] → btn:[Open directory...] → Select the `ui` directory inside the downloaded source code (for example `C:\Users\your.user\git\openems\ui`) → btn:[Select directory]

. Open the integrated terminal:
+
Menu: btn:[Show] → btn:[Integrated terminal]

. Install https://cli.angular.io/[Angular CLI icon:external-link[]]:
+
`npm install -g @angular/cli`

. Resolve and download dependencies:
+
`npm install`

=== Run OpenEMS UI

. In Visual Studios integrated terminal type...
+
`ng serve`
+
The log shows:
+
`NG Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/`

. Open a browser at http://localhost:4200

. You should see OpenEMS UI. Log in as user "guest" by clicking on the tick mark. Alternatively type "admin" in the password field to log in with extended permissions.
+
.OpenEMS UI Login screen
image::openems-ui-login.png[OpenEMS UI Login screen]

. Change to the Energymonitor by clicking on the arrow.
+
.OpenEMS UI Overview screen
image::openems-ui-overview.png[OpenEMS UI Overview screen]

. You should see the Energymonitor showing the same data as the DebugLog output on the console.
+
.OpenEMS UI Energymonitor screen
image::openems-ui-edge-overview.png[OpenEMS UI Energymonitor screen]
+
NOTE: OpenEMS UI will complain that "no timedata source is available". Because of this the historic chart is not yet functional.

== Core concepts & terminology

This chapter describes some of the core concepts and commonly used terms in OpenEMS:

=== OSGi Bundle

OpenEMS Edge is using the https://en.wikipedia.org/wiki/OSGi[OSGi icon:external-link[]] platform to provide a completely modular and dynamic service oriented system.

Logical groups of source code are put into one OSGi Bundle. Every directory in the source code root directory starting with 'io.openems.*' is a bundle. 

=== OpenEMS Component

OpenEMS Edge is built of Components, i.e. every main component implements the link:../io.openems.edge.common/src/io/openems/edge/common/component/OpenemsComponent.java[OpenemsComponent interface icon:code[]]. 

By definition each Component has a unique ID. Those *Component-IDs* are typically:

* `ess0` for the first storage system or battery inverter
* `ess1` for the second storage system or battery inverter
* ...
* `meter0` for the first meter in the system
* ...

If you receive your OpenEMS together with a FENECON energy storage system, you will find the following Component-IDs:

* FENECON Pro
** `ess0`: FENECON Pro Ess
// TODO link:../edge/src/io/openems/impl/device/pro/FeneconProEss.java[FENECON Pro Ess icon:code[]]
** `meter0`: Socomec grid meter
// TODO link:../edge/src/io/openems/impl/device/socomec/SocomecMeter.java[Socomec grid meter icon:code[]]
** `meter1`: FENECON Pro production meter 
// TODO link:../edge/src/io/openems/impl/device/pro/FeneconProPvMeter.java[FENECON Pro production meter icon:code[]]

* FENECON Mini
** `ess0`: FENECON Mini
// TODO link:../edge/src/io/openems/impl/device/minireadonly/FeneconMiniEss.java[FENECON Mini icon:code[]]
** `meter0`: FENECON Mini grid meter
// TODO link:../edge/src/io/openems/impl/device/minireadonly/FeneconMiniGridMeter.java[FENECON Mini grid meter icon:code[]]
** `meter1`: FENECON Mini production meter
// TODO link:../edge/src/io/openems/impl/device/minireadonly/FeneconMiniProductionMeter.java[FENECON Mini production meter icon:code[]]

=== Channel

Each OpenemsComponent provides a number of Channels. Each represents a single piece of information. Each Channel implements the link:../io.openems.edge.common/src/io/openems/edge/common/channel/Channel.java[Channel interface icon:code[]]. By definition each Channel has a unique ID within its parent Component.

=== Nature

Natures extend normal Java interfaces with 'Channels'. If a Component implements a Nature it also needs to provide the required Channels. For example the Energy Storage System (ESS) Simulator link:../io.openems.edge.simulator/src/io/openems/edge/simulator/ess/symmetric/reacting/EssSymmetric.java[Simulator.EssSymmetric.Reacting icon:code[]] implements the link:../io.openems.edge.ess.api/src/io/openems/edge/ess/api/Ess.java[Ess interface icon:code[]] and therefor needs to provide a `Soc` Channel that provides the current 'State of Charge' of the battery.

<<Controller>>s are written against Nature implementations. Example: A Controller can be used with any ESS, because it can be sure that it provides all the data the Controller requires for its algorithm.

// TODO: add link to all Natures below. Existing Nature implementations are described below.

=== Channel Address

By combining the unique *Component-ID* and *Channel-ID* each Channel in the system can be addressed by a distinct 'Channel Address' in the form `Component-ID/Channel-ID`.

Example: the state of charge ("Soc") of the first energy storage system ("ess0") has the channel address `ess0/Soc`.

=== Scheduler

The Scheduler handles the order, in which Controllers are executed. For details see <<Scheduler and Controller>> below.

// TODO: add link to all Schedulers below. Existing Scheduler implementations are described below.

=== Controller

The actual business logic or algorithms are wrapped as 'Controllers'. i.e. they implement the link:../io.openems.edge.controller.api/src/io/openems/edge/controller/api/Controller.java[Controller interface icon:code[]]. Each Controller holds one specific, encapsulated task.

// TODO: add link to all Controllers below. Existing Controller implementations are described below.

== OpenEMS Edge

OpenEMS Edge is the core component of the energy management that runs on-site and is responsible for communicating with and controling of external hardware like battery systems, inverters, meters and so on.

=== Architecture

The OpenEMS Edge software architecture is carefully designed to abstract device communication and control algorithms in a way to provide maximum flexibility, predictability and stability, while simplifying the process of implementing new components.

==== Input-Process-Output

OpenEMS Edge is built around the well-known IPO (input-process-output) model which defines the internal execution cycle.

.Input-Process-Output model
image::input-process-output.png[Input-Process-Output model]

Input::
During the input phase all relevant information - e.g. the current 'state of charge' of a battery - is collected and provided as a *process image*. This process image is guaranteed to never change during the cycle.

Process::
The process phase runs algorithms and tasks based on the process image - e.g. an algorithm uses the 'state of charge' information to evaluate whether a digital output should be turned on.

Output::
The output phase takes the results from the process phase and applies it - e.g. it turns the digital output on or off.

==== Scheduler and Controller

During the 'process' phase different algorithms (Controllers) might try to access the same resources - e.g. two Controllers try to switch the same digital output. It is therefor necessary to prioritize their execution and restrict access according to priority.

OpenEMS Edge uses Scheduler implementations to receive a sorted list of Controllers. The Controllers are then executed in order. Later executed Controllers are not allowed to overwrite a previously written result. 

.IPO model with Scheduler and Controllers
image::input-process-scheduler-output.png[IPO model with Scheduler and Controllers]

==== Cycle

The input-process-output model in OpenEMS Edge is executed in a Cycle - implemented by the link:../io.openems.edge.core/src/io/openems/edge/cycle/Cycle.java[Cycle component icon:code[]]). It handles the setting of a process image in the input phase and executes the Controllers in the process phase. Furthermore it emits Cycle Events that can be used in other Components to synchronize with the Cycle.  

.OpenEMS Edge Cycle
image::edge-cycle.png[OpenEMS Edge Cycle]

==== Asynchronous threads and Cycle synchronization

Communication with external hardware and services needs to be executed in asynchronous threads to not block the system. At the same time, those threads need to synchronize with the Cycle.

The following example shows, how the link:../io.openems.edge.bridge.modbus/src/io/openems/edge/bridge/modbus/AbstractModbusBridge.java[Modbus implementation icon:code[]] uses Cycle Events to synchronize with the Cycle:

.Synchronize Cycle with Modbus read/write 
image::cycle-modbus.png[Synchronize Cycle with Modbus read/write]

==== Architecture scheme

The following scheme shows the abstraction of hardware via Channels, Natures and Devices as well as the execution of control algorithms via Scheduler and Controllers.

.Architecture scheme 
image::device-nature-channel-scheduler-controller.png[Architecture scheme]

=== Configuration

OpenEMS Edge and Backend are configured using the standard OSGi configuration admin service. The easiest way to set a configuration is via the http://localhost:8080/system/console/configMgr[Apache Felix Web Console Configuration icon:external-link[]] as described in the <<_getting_started>> guide above.

.Apache Felix Web Console Configuration
image::apache-felix-console-configuration.png[Apache Felix Web Console Configuration]

Configuration via OpenEMS UI is currently not available due to the ongoing <<_migration_to_osgi>>. Once migration is finished, it is going to be possible to change every configuration using the settings menu in OpenEMS UI - directly to OpenEMS Edge and via Backend.

.OpenEMS UI Configuration
image::ui-config.png[OpenEMS UI Configuration]

=== Hardware

This chapter covers hardware related topics around OpenEMS Edge.
It describes how physical hardware is abstracted using _Natures_, how standardized physical connection layers and protocols are implemented using _Bridges_ and shows which _Devices and Services_ are implemented. The chapter concludes with a development tutorial on how to implement a device. 

==== Natures

Physical hardware is abstracted in OpenEMS Edge using _Natures_. A Nature defines a set of characteristics and attributes which need to be provided by each OpenEMS component that implements it. These characteristics are defined by Channels. For example an implementation of an `Ess` (Energy Storage System), needs to provide an `Soc`-Channel (State of charge of the battery).

Technically Natures are implemented as OSGi API Bundles.

===== ESS (Energy Storage System)

An Energy Storage System is an integrated system with battery and battery inverter.

link:../io.openems.edge.ess.api/src/io/openems/edge/ess/api/Ess.java[Ess icon:code[]]::
A generic Energy Storage System
+
|===
include::_include/nature/Ess.adoc[tag=channels]
|===

link:../io.openems.edge.ess.api/src/io/openems/edge/ess/symmetric/readonly/api/SymmetricEssReadonly.java[SymmetricEssReadonly icon:code[]]::
A symmetric Energy Storage System in readonly-mode.
// TODO add channels

link:../io.openems.edge.ess.api/src/io/openems/edge/ess/symmetric/api/SymmetricEss.java[SymmetricEss icon:code[]]::
A symmetric, controllable Energy Storage System.
// TODO add channels

// TODO: describe SymmetricPower 'Active/Reactive Power circle' + callback

link:../io.openems.edge.ess.api/src/io/openems/edge/ess/dccharger/api/EssDcCharger.java[EssDcCharger icon:code[]]::
A solar charger that is connected to DC side of an energy storage system. 
// TODO add channels

===== Meter

link:../io.openems.edge.meter.api/src/io/openems/edge/meter/api/Meter.java[Meter icon:code[]]::
A generic electric power meter.
// TODO add channels

link:../io.openems.edge.meter.api/src/io/openems/edge/meter/symmetric/api/SymmetricMeter.java[SymmetricMeter icon:code[]]::
A power meter for symmetric metering.
// TODO add channels

link:../io.openems.edge.meter.api/src/io/openems/edge/meter/asymmetric/api/AsymmetricMeter.java[AsymmetricMeter icon:code[]]::
A power meter for asymmetric metering.
// TODO add channels

===== EVCS (Electric Vehicle Charging Station)

link:../io.openems.edge.evcs.api/src/io/openems/edge/evcs/api/Evcs.java[Evcs icon:code[]]::
A charging station for electric vehicles like e-cars and e-buses.
// TODO add channels

===== I/O (Digital Input/Output)

link:../io.openems.edge.io.api/src/io/openems/edge/io/api/DigitalOutput.java[DigitalOutput icon:code[]]::
One or more digital outputs or relays. 
// TODO add channels

==== Bridges

To simplify the implementation of hardware that is connected via certain standardized physical connection layers and protocols, those are implemented as Bridges. 

===== Modbus/TCP

link:../io.openems.edge.bridge.modbus/src/io/openems/edge/bridge/modbus/BridgeModbusTcp.java[Modbus/TCP icon:code[]]::
https://en.wikipedia.org/wiki/Modbus[Modbus/TCP icon:external-link[]] is a widely used standard for fieldbus connections via TCP/IP network. It is used by all kinds of hardware devices like photovoltaics inverters, electric meters, and so on.
// TODO add configuration settings

===== Modbus/RTU

link:../io.openems.edge.bridge.modbus/src/io/openems/edge/bridge/modbus/BridgeModbusSerial.java[Modbus/Serial icon:code[]]::
https://en.wikipedia.org/wiki/Modbus[Modbus/RTU icon:external-link[]] is a widely used standard for fieldbus connections via RS485 serial bus. It is used by all kinds of hardware devices like photovoltaics inverters, electric meters, and so on.
// TODO add configuration settings

==== Devices & Services

// == KEBA KeContact

// The KEBA KeContact bridge is an implementation of the UDP protocol for KEBA KeContact electric vehicle charging stations. It has no specific configuration in itself, as the configuration is happening in the DeviceNature.

// OpenEMS configuration:
// [source,json]
// ----
// {
// 	"class": "io.openems.impl.protocol.keba.KebaBridge",
// 	"devices": [
// 		... <1>
// 	]
// }
// ----
// <1> Configuration of KEBA deviceNatures (see below)

// Implementation: link:../edge/src/io/openems/impl/protocol/keba/KebaBridge.java[io.openems.impl.protocol.keba.KebaBridge icon:code[]]

==== Implementing a Device

===== Step-by-step guide

This chapter explains the steps required to implement a Device in OpenEMS Edge. The example shows the implementation of a http://www.socomec.co.uk/range-single-circuit-multifunction-meters_en.htlm?product=/diris-a14_en.html[SOCOMEC DIRIS A14 power meter icon:external-link[]]. The communication is via Modbus/RTU. The actual source code of the implementation can be found link:../io.openems.edge.meter.socomec.dirisa14/src/io/openems/edge/meter/socomec/dirisa14/MeterSocomecDirisA14.java[here icon:code[]]. 

The tutorial is based on the <<_getting_started>> guide.

====== Create a new OSGi Bundle

For more information see <<_osgi_bundle>>.

. In the menu choose btn:[File] -> btn:[New] -> btn:[Other]
+
.Creating a new project in Eclipse IDE
image::eclipse-file-new-other.png[Creating a new project in Eclipse IDE]

. Select btn:[Bndtools] -> btn:[Bnd OSGi Project] and press btn:[Next >]
+
.Creating a Bnd OSGi Project in Eclipse IDE
image::eclipse-bndtools-osgi-project.png[Creating a Bnd OSGi Project in Eclipse IDE]

. Select btn:[OSGi enRoute] -> btn:[Provider/Adapter Bundle] and press btn:[Next >]
+
NOTE: Technically an OpenEMS Edge Device provides implementations of the interfaces of an OSGi _API Bundle_. In OSGi terminology this is called a _Provider/Adapter Bundle_ 
+
.Creating a Bnd OSGi Provider/Adapter Bundle in Eclipse IDE
image::eclipse-new-osgi-provider-bundle.png[Creating a Bnd OSGi Provider/Adapter Bundle in Eclipse IDE]

. Choose a project name and press btn:[Next >]
+
NOTE: The project name is used as the folder name in OpenEMS source directory. The naming is up to you, but it is good practice to keep the name lower case and use something like *io.openems.[edge/backend].[purpose/nature].[implementation]*. For a SOCOMEC DIRIS A14 that is implementing the Meter nature `io.openems.edge.meter.socomec.dirisa14` is a good choice.
+
.Naming a Bnd OSGi Provider/Adapter Bundle in Eclipse IDE
image::eclipse-new-osgi-provider-socomec.png[Naming a Bnd OSGi Provider/Adapter Bundle in Eclipse IDE]

. Accept defaults for the final screen and press btn:[Finish]
+
.Java settings for a Bnd OSGi Provider/Adapter Bundle in Eclipse IDE
image::eclipse-new-osgi-provider-socomec-final.png[Java settings for a Bnd OSGi Provider/Adapter Bundle in Eclipse IDE]

. The assistant closes and you can see your new bundle.

====== Define Bundle dependencies

OSGi Bundles can be dependent on certain other Bundles. This information can be set in a *bnd.bnd* file.

. Select the component directory btn:[src] -> btn:[io.openems.edge.meter.socomec.dirisa14]
+
.New SOCOMEC DIRIS A14 Bnd OSGi Provider/Adapter Bundle in Eclipse IDE
image::eclipse-new-socomec-bundle.png[New SOCOMEC DIRIS A14 Bnd OSGi Provider/Adapter Bundle in Eclipse IDE]

. Open the btn:[bnd.bnd] file by double clicking on it.

. Open the btn:[Build] tab
+
NOTE: You can see, that the Bundle is currently dependent on a core OSGi API bundle ('osgi.enroute.base.api'). We are going to expand that list.
+
.Bndtools Build configuration
image::eclipse-bnd-file-build.png[Bndtools Build configuration]

. Click the btn:[+] symbol next to *Build Path*.
+
.Bndtools Build Path configuration
image::eclipse-osgi-build-path.png[Bndtools Build Path configuration]

. Use the *Project Build Path* assistant to add the following Bundles as dependencies:
+
io.openems.edge.common::
The Edge Common Bundle provides implementations and services that are common to all OpenEMS Edge components. 
+
io.openems.edge.meter.api::
The Meter API Bundle provides the interfaces for OpenEMS Edge Meter Nature.
+
io.openems.edge.bridge.modbus::
The Modbus Bundle provides the Bridge services for Modbus/RTU and Modbus/TCP protocols.

. It is also a good moment to configure the Bundle meta information. Still inside the btn:[bnd.bnd] file open the btn:[Source] tab. Add some meta information - it will help the users of your component:
+
[source]
----
Bundle-Name: OpenEMS Edge Meter SOCOMEC DirisA14
Bundle-Vendor: FENECON GmbH
Bundle-License: https://opensource.org/licenses/EPL-2.0
Bundle-Version: 1.0.0.${tstamp}
Export-Package: \
	io.openems.edge.meter.api,\
	io.openems.edge.meter.asymmetric.api,\
	io.openems.edge.meter.symmetric.api
Private-Package: io.openems.edge.meter.socomec.dirisa14

-includeresource: {readme.md}

-buildpath: \
	osgi.enroute.base.api;version=2.1,\
	io.openems.edge.meter.api;version=latest,\
	io.openems.edge.bridge.modbus;version=latest,\
	io.openems.edge.common;version=latest

-testpath: \
	osgi.enroute.junit.wrapper;version=4.12, \
	osgi.enroute.hamcrest.wrapper;version=1.3
----

====== Define configuration parameters

OpenEMS Components can have several configuration parameters. They are defined as Java annotations and specific OSGi annotations are used to generate meta information that is used e.g. by Apache Felix Web Console to generate a user interface form (see <<_getting_started>>).  

. Make sure that the component directory is still selected.

. In the menu choose btn:[File] -> btn:[New] -> btn:[Other]

. Select btn:[Java] -> btn:[Class] and press btn:[Next >]
+
.Creating a Java annotation in Eclipse IDE
image::eclipse-new-annotation.png[Creating a Java annotation in Eclipse IDE]

. Set the name *Config* press btn:[Finish].
+
.Creating the Java annotation 'Config' in Eclipse IDE
image::eclipse-new-config-annotation.png[Creating the Java annotation 'Config' in Eclipse IDE]

. A Java annotation template was generated for you:
+
[source,java]
----
package io.openems.edge.meter.socomec.dirisa14;

public @interface Config {

}
----

. Adjust the template to match the following code:
+
[source,java]
----
package io.openems.edge.meter.socomec.dirisa14;

import org.osgi.service.metatype.annotations.AttributeDefinition;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;

@ObjectClassDefinition( // <1>
		name = "Meter SOCOMEC Diris A14", //
		description = "Implements the SOCOMEC Diris A14 meter.")
@interface Config {
	String service_pid(); // <2>

	String id() default "meter0"; // <3>

	boolean enabled() default true; // <4>

	@AttributeDefinition(name = "Meter-Type", description = "Grid, Production (=default), Consumption") <5>
	MeterType type() default MeterType.PRODUCTION; <6>

	@AttributeDefinition(name = "Modbus-ID", description = "ID of Modbus brige.")
	String modbus_id(); <7>

	@AttributeDefinition(name = "Modbus Unit-ID", description = "The Unit-ID of the Modbus device.")
	int modbusUnitId(); <8>

	@AttributeDefinition(name = "Modbus target filter", description = "This is auto-generated by 'Modbus-ID'.")
	String Modbus_target() default ""; <9>

	@AttributeDefinition(name = "Minimum Ever Active Power", description = "This is automatically updated.")
	int minActivePower(); <10>

	@AttributeDefinition(name = "Maximum Ever Active Power", description = "This is automatically updated.")
	int maxActivePower(); <10>

	String webconsole_configurationFactory_nameHint() default "Meter SOCOMEC Diris A14 [{id}]"; <11>
}
----
<1> The *@ObjectClassDefinition* annotation defines this file as a Meta Type Resource for OSGi configuration admin. Use it to set a _name_ and _description_ for this OpenEMS Component.
// TODO add screenshot that shows how the strings are used in Apache
<2> The *service_pid* is used in internally by OpenEMS Edge framework and is automatically filled by OSGi.
<3> The *id* configuration parameter sets the OpenEMS Component-ID (see <<_channel_address>>). _Note_: A *default* ID 'meter0' is defined. It is good practice to define such an ID here, as it simplifies configuration in the UI.
<4> The *enabled* parameter provides a _soft_ way of deactivating an OpenEMS Component programmatically.
<5> The *@AttributeDefinition* annotation provides meta information about a configuration parameter like _name_ and _description_.
<6> The 'Meter' nature requires definition of a MeterType that defines the purpose of the Meter. We will let the user define this type by a configuration parameter.
<7> The 'Modbus-ID' parameter creates the link to a Modbus-Service via its OpenEMS Component-ID. At runtime the user will typically set this configuration parameter to something like 'modbus0'.
<8> The Modbus service implementation requires us to provide the Modbus _Unit-ID_ (also commonly called _Device-ID_ or _Slave-ID_) of the Modbus slave device. This is the ID that is configured at the SOCOMEC DIRIS.
<9> The *Modbus_target* will be automatically set by OpenEMS framework and does usually not need to be configured by the user. _Note_: Linking other OpenEMS Components is implemented using OSGi References. The OpenEMS Edge framework therefor sets the 'target' property of a reference to filter the matched services.
<10> The default Meter implementation uses configuration parameters *minActivePower* and *maxActivePower* to store the minimum/maximum ever experienced active power. By providing them here the User can possibly adjust them if required.
<11> The *webconsole_configurationFactory_nameHint* parameter sets a custom name for Apache Felix Web Console, helping the user to find the correct bundle.

====== Implement the OpenEMS Component

Next step is to actually implement the OpenEMS Component as an OSGi Bundle.

. The Bndtools assistant created a `ProviderImpl.java` file. First step is to set a proper name for this file. To rename the file, select it by clicking on it and choose btn:[Refactor] -> btn:[Rename...] in the menu. Write `MeterSocomecDirisA14` as 'New name' and press btn:[Finish]. 
+
.Renaming a Java class in Eclipse IDE
image::eclipse-rename.png[Renaming a Java class in Eclipse IDE]
+
Afterwards the `MeterSocomecDirisA14.java` file has the following content:
+
[source,java]
----
package io.openems.edge.meter.socomec.dirisa14;

import java.util.Map;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;
import org.osgi.service.metatype.annotations.Designate;

@Designate(ocd = MeterSocomecDirisA14.Config.class, factory = true) // <1>
@Component(name = "io.openems.edge.meter.socomec.dirisa14") // <2>
public class MeterSocomecDirisA14 {

	@ObjectClassDefinition
	@interface Config { // <3>
		String name() default "World";
	}

	private String name;

	@Activate
	void activate(Config config) { <4>
		this.name = config.name();
	}

	@Deactivate <5>
	void deactivate() {
	}

}
----
<1> The *@Designate* annotation is used for OSGi to create a connection to a _Config_ annotation class. It also defines this Component as a _factory_, i.e. it can produce multiple instances with different configurations.
<2> The *@Component* annotation marks this class as an OSGi component and sets a unique name.
<3> The template for _OSGi Provider/Adapter Bundles_ comes with an embedded example Config definition.
<4> The *activate()* method (marked by the *@Activate* annotation) is called on activation of an object instance of this Component. It comes with an instance of a configuration in the form of a Config object.
<5> The *deactivate()* method (marked by the *@Deactivate* annotation) is called on deactivation of the Component instance.

. We can see, that by default there is an embedded '@interface Config' file. Which is referred to by the '@Designate' annotation. As we implemented our own *Config.java* file externally, we can adjust as follows to use our implementation:
+
[source,java]
----
package io.openems.edge.meter.socomec.dirisa14;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.metatype.annotations.Designate;

@Designate(ocd = Config.class, factory = true)
@Component(name = "io.openems.edge.meter.socomec.dirisa14")
public class MeterSocomecDirisA14 {

	@Activate
	void activate(Config config) {
	}

	@Deactivate
	void deactivate() {
	}

}
----

. It is good practice to adjust the *@Component* annotation a little bit:
+
[source,java]
----
@Component(name = "Meter.SOCOMEC.DirisA14", // <1>
		immediate = true, // <2>
		configurationPolicy = ConfigurationPolicy.REQUIRE) // <3>
----
<1> Configure a human-readable name in the form *[nature].[vendor].[product]*.
<2> Configure the Component to be started immediately after configuration, i.e. it is not waiting till its service is required by another Component.
<3> Define that the configuration of the Component is required before it gets activated.

. We have an OSGi Component. To make it an OpenEMS Edge Component, we need to implement the *OpenemsComponent* interface. To ease the implementation of all required functionalities we can simply inherit from the *AbstractOpenemsComponent* class. As our device is connected using Modbus, there is an additional convinience layer in the form of the *AbstractOpenemsModbusComponent* available.
+
NOTE: In plain Java it is not required to add `implements OpenemsComponent` if we inherit from 'AbstractOpenemsComponent' or 'AbstractOpenemsModbusComponent'. Be aware that for OSGi dependency injection to function properly, it is stil required to mention all implemented interfaces again, as it is not considering the complete inheritance tree.
+
We adjust the code as follows:
+
[source,java]
----
@Designate(ocd = Config.class, factory = true)
@Component(name = "Meter.SOCOMEC.DirisA14", //
		immediate = true, //
		configurationPolicy = ConfigurationPolicy.REQUIRE)
public class MeterSocomecDirisA14 extends AbstractOpenemsModbusComponent implements OpenemsComponent { <1>

	@Activate
	void activate(ComponentContext context, Config config) { <2>
		super.activate(context, config.service_pid(), config.id(), config.enabled(), config.modbusUnitId(), this.cm,
				"Modbus", config.modbus_id()); <3>
	}

	@Deactivate
	protected void deactivate() {
		super.deactivate(); <3>
	}

}
----
<1> The class extends *AbstractOpenemsModbusComponent* and specifically implements *OpenemsComponent* again. This makes it an <<_openems_component>>.
<2> The *activate()* method can be adjusted to not only take a Config object, but also provides a _ComponentContext_. OSGi takes care of providing both on activation of the Component.
<3> All logic for activating and deactivating the OpenEMS Component is hidden in the super class and just needs to be called from here.
+
Note that after this step you will still see two errors: Eclipse complains that we need to implement a method `defineModbusProtocol()` and that it does not know `this.cm`. We will fix that in the next two steps.

. The `super.activate()` method requires an instance of *ConfigurationAdmin* as a parameter. The ConfigurationAdmin is an external service which can be provided to our Component via dependency injection. Using OSGi Declarative Services annotations we just need to add the following two lines within the class - OSGi takes care of the rest:
+
[source,java]
----
@Reference
protected ConfigurationAdmin cm;
----
+
This solves the first error. We can now refer to an instance of _ConfigurationAdmin_ via `this.cm`.

. _AbstractOpenemsModbusComponent_ requires us to implement a *defineModbusProtocol()* method that returns an instance of *ModbusProtocol*. The _ModbusProtocol_ class maps Modbus addresses to OpenEMS <<_channel>>s and provides some conversion utilities. Instantiation of a _ModbusProtocol_ object heavily uses the https://en.wikipedia.org/wiki/Builder_pattern#Java[Builder pattern icon:external-link[]] 
+
[source,java]
----
@Override
protected ModbusProtocol defineModbusProtocol(int unitId) {
    return new ModbusProtocol(unitId, // <1>
            new FC3ReadRegistersTask(0xc558, Priority.HIGH, // <2>
                    ...
                    m(AsymmetricMeter.ChannelId.CURRENT_L1, new UnsignedDoublewordElement(0xc560)), // <3>
                    ...
                    m(SymmetricMeter.ChannelId.ACTIVE_POWER, new SignedDoublewordElement(0xc568),ElementToChannelConverter.SCALE_FACTOR_1), // <4>
                    ...
                    new DummyRegisterElement(0xc56C, 0xc56F), // <5>
                    ...
                    cm(new UnsignedDoublewordElement(0xc558)) // <6>
                        .m(AsymmetricMeter.ChannelId.VOLTAGE_L1, ElementToChannelConverter.SCALE_FACTOR_1) //
                        .m(SymmetricMeter.ChannelId.VOLTAGE, ElementToChannelConverter.SCALE_FACTOR_1) //
                        .build(), //
            ));
}
----
<1> Creates a *new ModbusProtocol* instance. The Modbus *Unit-ID* - which is provided by the method itself - is the first parameter, followed by an arbitrary number of 'Tasks' (implemented as a Java varags array).  
<2> *FC3ReadRegistersTask* is an implementation of Modbus http://www.simplymodbus.ca/FC03.htm[function code 3 "Read Holding Registers" icon:external-link[]]. Its first parameter is the start address of the register block. The second parameter is a priority information that defines how often this register block needs to be queried. Following parameters are an arbitrary number of *ModbusElements*
<3> This command uses the internal *m()* method to make a simple 1-to-1 mapping between the Modbus element at address `0xc560` and the Channel _AsymmetricMeter.ChannelId.CURRENT_L1_. The Modbus element is defined as a 32 bit doubleword element with an unsigned integer value.
<4> The _m()_ method also takes an instance of *ElementToChannelConverter* as an additional parameter. This example uses _ElementToChannelConverter.SCALE_FACTOR_1_ to add a scale factor to the conversion that converts a Modbus read value of "95" to a channel value of "950".
<5> For Modbus registers that are empty or should be ignored, the *DummyRegisterElement* can be used.
<6> This example uses the internal method *cm()* which provides more advanced channel-to-element mapping functionalities. The example maps the Modbus element to two Channels.
+
Using this principle a complete Modbus table consisting of multiple register blocks that need to be read or written with different Modbus function codes can be defined. For details have a look at the existing implementation classes inside the Modbus Bridge source code.

. OpenEMS <<_channel>>s have a two-stage implementation. _Declaration_ happens inside the Nature - for common Channels - and the Component - for custom Channels specific to the Device. _Definition_ (i.e. instantiation of the Channel object) happens inside the Component.
+
For now we only used Channels defined by the Meter Nature, e.g. link:../io.openems.edge.meter.api/src/io/openems/edge/meter/symmetric/api/SymmetricMeter.java[SymmetricMeter.ChannelId.ACTIVE_POWER' icon:code[]]. It is still good practice to add a skeleton for custom Channels *Declaration* to the Component implementation. We therefor add the following _Channel Declaration_ block inside the class:
+
[source,java]
----
public enum ChannelId implements io.openems.edge.common.channel.doc.ChannelId { // <1>
    ; // <2>
    private final Doc doc;

    private ChannelId(Doc doc) { // <3>
        this.doc = doc;
    }

    public Doc doc() {
        return this.doc;
    }
}
----
<1> Channel declarations are *enum* types implementing the ChannelId interface.
<2> This enum is empty, as we do not have custom Channels here.
<3> ChannelId enums require a Doc object that provides meta information about the Channel - e.g. the above ACTIVE_POWER Channel is defined as `ACTIVE_POWER(new Doc().type(OpenemsType.INTEGER).unit(Unit.WATT)`
+
After the Declaration of the Channels we also need the *Definition*.
A good place for the Definition of the Channels is inside the object constructor, to be sure that the Channels are always defined and avoid NullPointerExceptions. 
It is good practice to move Channel definition to an external static _Utils.initializeChannels()_ method to keep our Component file short and clean.
We use Java Streams to facilitate the Definition of Channels
+
Create a new file *Utils.java* with the following content:
+
[source,java]
----
package io.openems.edge.meter.socomec.dirisa14;

import java.util.Arrays;
import java.util.stream.Stream;

import io.openems.edge.common.channel.AbstractReadChannel;
import io.openems.edge.common.channel.IntegerReadChannel;
import io.openems.edge.common.channel.StateChannel;
import io.openems.edge.common.component.OpenemsComponent;
import io.openems.edge.meter.api.Meter;
import io.openems.edge.meter.asymmetric.api.AsymmetricMeter;
import io.openems.edge.meter.symmetric.api.SymmetricMeter;

public class Utils {
	public static Stream<? extends AbstractReadChannel<?>> initializeChannels(MeterSocomecDirisA14 c) { // <1>
		return Stream.of( //
				Arrays.stream(OpenemsComponent.ChannelId.values()).map(channelId -> { // <2>
					switch (channelId) { // <3>
					case STATE:
						return new StateChannel(c, channelId); // <4>
					}
					return null;
				}), Arrays.stream(Meter.ChannelId.values()).map(channelId -> { // <2>
					switch (channelId) { // <3>
					case FREQUENCY:
						return new IntegerReadChannel(c, channelId); // <4>
					}
					return null;
				}), Arrays.stream(SymmetricMeter.ChannelId.values()).map(channelId -> { // <2>
					switch (channelId) { // <3>
					case ACTIVE_POWER:
						return new IntegerReadChannel(c, channelId); // <4>
					}
					return null;
				}), Arrays.stream(AsymmetricMeter.ChannelId.values()).map(channelId -> { // <2>
					switch (channelId) { // <3>
					case ACTIVE_POWER_L1:
					case ACTIVE_POWER_L2:
					case ACTIVE_POWER_L3:
						return new IntegerReadChannel(c, channelId); // <4>
					}
					return null;
				})/*
					 * , Arrays.stream(MeterSocomecDirisA14.ChannelId.values()).map(channelId -> {
					 * switch (channelId) { } return null; })
					 */ //
		).flatMap(channel -> channel);
	}
}
----
<1> The static *initializeChannels()* method returns a Java Stream of Channel objects.
<2> Using Streams the Java lambda function is called for each declared ChannelId. This command is repeated for every Nature that is implemented by the OpenEMS Component.
<3> Using a switch-case statement each ChannelId can be evaluated. _Note:_ Because we are using enums together with switch-case, Eclipse IDE is able to find out if we covered every Channel and post a warning if we did not.
<4> This line creates the actual Definition of the Channel and returns a Channel object instance of the required type.
+
Note that after this step you will see many warnings like 'The enum constant CURRENT needs a corresponding case label in this enum switch on SymmetricMeter.ChannelId'. Eclipse IDE 'Quick Fix' provides an option 'Add missing case statements' that will generate the missing switch-cases for you.
+
.Eclipse IDE Quick Fix for switch-case
image::eclipse-channels-switch-case.png[Eclipse IDE Quick Fix for switch-case]
+
Finally we need to call the _Utils.initializeChannels()_ from the Component constructor. Add the following code to the Component code. It receives a Stream of Channel objects and adds all of them to the Component using the `addChannel()` method.
+
[source,java]
----
public MeterSocomecDirisA14() {
    Utils.initializeChannels(this).forEach(channel -> this.addChannel(channel));
}
----

. Our OpenEMS Component utilizes an external Modbus Component for the actual Modbus communication. We receive an instance of this service via dependency injection (like we did already for the _ConfigurationAdmin_ service). Most of the magic is handled by the _AbstractOpenemsModbusComponent_ implementation. We only need to add the following code to the Component:
+
[source,java]
----
@Reference(policy = ReferencePolicy.STATIC, policyOption = ReferencePolicyOption.GREEDY, cardinality = ReferenceCardinality.MANDATORY)
protected void setModbus(BridgeModbus modbus) {
    super.setModbus(modbus);
}
----

. The Device that we are implementing provides the Natures *SymmetricMeter, AsymmetricMeter and Meter*. We already defined those in the _initializeChannels()_ method. Additionally the Component also needs to implement the Nature interfaces.
+
Change the class declaration as follows:
+
[source,java]
----
public class MeterSocomecDirisA14 extends AbstractOpenemsModbusComponent
		implements SymmetricMeter, AsymmetricMeter, Meter, OpenemsComponent {
----

. The *Meter* Nature requires us to implement a `MeterType getMeterType()` method. The MeterType was provided by the Config, so we simply take the config parameter inside the _activate()_ method:
+
[source,java]
----
private MeterType meterType = MeterType.PRODUCTION; // <1>

@Activate
void activate(ComponentContext context, Config config) {
    // get Meter Type:
    this.meterType = config.type(); // <2>
    ...
}

@Override
public MeterType getMeterType() { // <3>
    return this.meterType;
}
----
<1> Declare the class variable _meterType_ with a default value.
<2> Store the config parameter.
<3> Implement the _getMeterType()_ method that returns the meterType.

. Meter stores the _Min/MaxActivePower_ as configuration parameters. This is handled internally and just needs to be initialized using the *SymmetricMeter._initializeMinMaxActivePower()* method inside the _activate()_ method.
+
[source,java]
----
this._initializeMinMaxActivePower(this.cm, config.service_pid(), config.minActivePower(), config.maxActivePower());
----

. Finally it is always a good idea to define a *debugLog()* method. This method is called in each cycle by the *Controller.Debug.Log* and very helpful for continuous debugging:
+
[source,java]
----
@Override
public String debugLog() {
    return "L:" + this.getActivePower().value().asString();
}
----

. To actually run the Component, open the *io.openems.edge.application* project and open the link:../io.openems.edge.application/EdgeApp.bndrun[EdgeApp.bndrun icon:code[]] file. Search for your Bundle and drag-and-drop it to the *Run Requirements*.
+
.Eclipse IDE EdgeApp.bndrun
image::eclipse-edgeapp-bndrun.png[Eclipse IDE EdgeApp.bndrun]
+
Press btn:[Resolve] to dissolve the dependencies and accept the _Resolution Results_ window with btn:[Finish].
+
Then press btn:[Run OSGi] to run OpenEMS Edge. From then you can configure your component as shown in <<_getting_started>>.

===== Synchronize device communication

===== Active/Reactive power control of a battery inverter

=== Scheduler

==== Existing Schedulers

==== Developing a Scheduler

=== Controller

==== Existing Controllers

===== Api Backend Controller

Establishes the connection to OpenEMS Backend.

===== Api REST/JSON Controller

Provides a REST-Api for external access to OpenEMS Edge. The default port for the server is *8084*; so the default base address for REST calls is `http://x:<PASSWORD>@<IP>:8084/rest`, where

- "http" is the protocol
- "x" is the user. Authentification in OpenEMS is via password only, so username can be anything.
- "<PASSWORD>" is the user password. If no specifi settings have been made, try 'user' or 'admin' here.
- "8084" is the configured port

A good way to test REST-Api calls is via the Chrome extension https://chrome.google.com/webstore/detail/restlet-client-rest-api-t/aejoelaoggembcahagimdiliamlcdmfm[Restlet]

Api-Endpoints:

- `/channel/<ThingId>/<ChannelName>`
+
Provides access to a channel value. Example: use a GET request to http://x:user@localhost:8084/rest/_sum/EssSoC to get the current average state of charge.

===== Api Websocket Controller

Server for connection from OpenEMS UI to OpenEMS Edge.

===== Channel-Threshold Controller

Switch I/Os according to Channel-Value, e.g. State-of-Charge of the battery.

===== Debug Detailed-Log Controller

Output detailed debug information about specific Components on the console.

===== Debug Log Controller

Output generic information about every Component on every cycle.

===== Ess Limit Total Discharge

Avoid total discharge of an energy storage system (ESS). Allows to define a Min-SoC and Force-Charge-SoC.

===== Symmetric Balancing Controller

Symmetric self-consumption optimization.

===== Symmetric Fix-Active-Power Controller

Allows setting of a fixed Active-Power value for an ESS.

===== Symmetric Fix-Reactive-Power Controller

Allows setting of a fixed Reactive-Power value for an ESS.

==== Developing a Controller

=== Build OpenEMS Edge

This chapter explains, how OpenEMS Edge can be compiled to a JAR file that can be executed outside of an IDE.

==== Build using Eclipse IDE

. Inside Eclipse IDE open the *io.openems.edge.application* project and open the link:../io.openems.edge.application/EdgeApp.bndrun[EdgeApp.bndrun icon:code[]] file.
+
.Eclipse IDE EdgeApp.bndrun
image::eclipse-edgeapp-bndrun.png[Eclipse IDE EdgeApp.bndrun]

. Press btn:[Export] to start the *Export Wizard Selection* assistant.

. Select btn:[Executable JAR] and press btn:[Next >].
+
.Eclipse Export Wizard Selection assistant
image::eclipse-bnd-file-export.png[Eclipse Export Wizard Selection assistant]

. Select a *Destination* for *Export to JAR*.
+
.Eclipse Export Destination
image::eclipse-bnd-file-export-destination.png[Eclipse Export Destination]

. Press btn:[Finish]

This creates a so called Fat-JAR-file including all bundles. It can be executed by running `java -jar openems.jar` in a console.

==== Build using bnd from command line

. Install bnd on the command line. See https://github.com/bndtools/bnd/wiki/Install-bnd-on-the-command-line[bnd wiki icon:external-link[]] for details. (Following I assume that you download the biz.aQute.bnd.jar file to the parent directory of your repository.)

. Open a console and change to your repository directory.

. Execute `java -jar biz.aQute.bnd.jar package -o openems.jar io.openems.edge.application\EdgeApp.bndrun`

. This creates a Fat-JAR 'openems.jar' in the base directory of the repository.

=== Deploy OpenEMS Edge

This chapter explains how OpenEMS can be deployed on a Debian Linux Internet-of-Things Gateway. Similar techniques will work for other operating systems as well.

This guide covers a simple, manual approach. For productive systems it is required to automate deployment to IoT devices. Good approaches include a Debian package repository that provides *.deb-files and third-party tools like http://www.eclipse.org/hawkbit/[Eclipse Hawkbit]. This is out-of-scope for this small guide.

Prerequisites:

* A target device running Debian Linux like a Raspberry Pi, Beaglebone Black or an IoT gateway. You need the IP address and SSH access.
* Create a JAR-file that should be deployes. See <<_build_openems_edge>> for details.
* Setup an SSH client to connect to the Linux console, e.g. http://www.9bis.net/kitty/[KiTTY]
* Setup an SCP client to copy the JAR file via SSH, e.g. https://winscp.net/eng/docs/lang:de[WinSCP]

==== Connect via SSH and SCP

. Connect via SSH using KiTTY
.. Open KiTTY and connect to the target device.
+
Make sure to select SSH with port 22 and enter the IP address of the target device. Press the btn:[Open] button.
+
.KiTTY Configuration
image::deploy-kitty.png[KiTTY Configuration]

.. Gain root permissions either by logging in as user *root* or by login in as a default user and executing *sudo -s*.
+
.KiTTY Configuration
image::deploy-ssh-root.png[KiTTY Configuration]
+
NOTE: As an example, for the FENECON Energy Management System (FEMS) it is required to: +
_login as:_ `fems` +
_fems@192.168.178.38's password:_ `device specific password` +
... +
_fems@femsXXX:~$_ `sudo -s` +
_[sudo] password for fems:_ `device specific password` +
_root@femsXXX:/home/fems#_

. Connect via SCP using WinSCP

.. If you are lucky and have a fully configured system, right-click on the KiTTY window bar and select btn:[Start WinSCP].
+
.Start WinSCP from KiTTY
image::deploy-kitty-start-winscp.png[Start WinSCP from KiTTY]

.. Otherwise open WinSCP separately, create a new connection, select *SCP* as protocol and enter again the IP address and port 22. Click btn:[Connect] once finished.
+
.Start WinSCP from KiTTY
image::deploy-winscp.png[Start WinSCP from KiTTY]

===== Prepare operating system environment

====== Create an application directory

Create the directory */usr/lib/openems*. This is going to be the place, where we put the JAR file.

Execute `mkdir /usr/lib/openems`.

====== Create a config directory

Create the directory */etc/openems.d*. This is going to be the place, where all the bundle configurations are held.

Execute `mkdir /etc/openems.d`.

====== Create a systemd service definition

The systemd 'Service Manager' manages system processes in a Debian Linux. We will create a systemd service definition file, so that systemd takes care of managing (starting/restarting/...) the OpenEMS Edge service.

. Create and open the service definition file.
+
Execute `nano /etc/systemd/system/openems.service`

. Paste the following content:
+
----
[Unit]
Description=OpenEMS <1>
After=network.target <2>

[Service]
User=root <3>
Group=root
Type=notify <4>
WorkingDirectory=/usr/lib/openems
LimitCORE=infinity
LimitRTPRIO=2
LimitRTTIME=60000000
CPUSchedulingPolicy=rr
CPUSchedulingPriority=1
ExecStart=/usr/lib/jvm/java-8-openjdk-armhf/bin/java -Dfelix.cm.dir=/etc/openems.d/ -jar /usr/lib/openems/openems.jar <5>
SuccessExitStatus=143 <6>
Restart=always <7>
RestartSec=10 <8>
WatchdogSec=60 <9>

[Install]
WantedBy=multi-user.target
----
<1> The name of the service.
<2> The service is allowed to start after network is available (e.g. to be able to access devices via ethernet connection)
<3> It is run as user 'root' to have access to all devices. It is recommended to change this for productive systems.
<4> OpenEMS notifies systemd once it is started up properly.
<5> The start command. It uses Java 8, sets the config directory to `/etc/openems.d` and runs the jar file at `/usr/lib/openems/openems.jar`
<6> In contrast to what systemd expects, Java exits with status 143 on success.
<7> Systemd _always_ tries to restart OpenEMS once it was quit.
<8> Systemd waits _10_ seconds till the next restart.
<9> Systemd expects OpenEMS to trigger its watchdog once every 60 seconds. OpenEMS is doing that by default if it detects that it is run by systemd.

. Press btn:[Ctrl] + btn:[x] to exit and btn:[y] to save the file.

. Activate the service definition:
+
Execute `systemctl daemon-reload`

===== Update OpenEMS Edge JAR file

To update the OpenEMS JAR file at the target device, it is required to copy the JAR file from your build directory (see <<_build_openems_edge>>) to `/usr/lib/openems/openems.jar` on the target device. Afterwards it is required to restart the systemd service

. Copy JAR file via SCP.
+
In WinSCP open your local build directory on the left side and */usr/lib/openems/* on the right side. Then drag and drop the file from left to right.
+
.WinSCP copy file
image::deploy-winscp-copy.png[WinSCP copy file]

. Restart OpenEMS systemd service.
+
Execute `systemctl restart openems --no-block; journalctl -lfu openems`
+
The command restarts the service (_systemctl restart openems_) while not waiting for the OpenEMS startup notification (_--no-block_). Then it directly prints the OpenEMS system log (_journalctl -lfu openems_).
+
.OpenEMS Edge start-up
image::deploy-openems-start.png[OpenEMS Edge start-up]

== OpenEMS UI

=== Architecture

=== Configuration

=== FAQ
// TODO * negative consumption

== OpenEMS Backend

=== Architecture

=== Configuration

== Simulation

OpenEMS provides several virtual devices for testing and development. To set up the simulation-environment follow the setup guide in <<_getting_started>>. The Apache Felix Web Console Configuration lists all OpenEMS component, but those which rely on external hardware can't be used for simulation. These are replaced by more generic components tagged with the "Simulator" prefix. Still, not all non-simulator devices rely on real hardware. Other components used in production, like Loggers, Controllers and Schedulers can be combined with the virtual devices to build a "living" system.

=== Types of Simulated Components

* **DataSource**: A data-source generates lists of data and provides them as a channel to other components. The data can be generated by different means, which could be an augmented random-generator or a reader for a specific data-format like the "Simulator Datasource: CSV Reader".
* **Devices**: Devices replace a hardware-component like a meter or an ess. There are two kinds of devices:
** **acting**: These devices act on their own. Their actions do not depend on other device's actions, but on data-sources.
** **reacting**: These devices analyse other device's channels/properties to deduce their own behavior.

=== Simulator Components

* `Simulator DataSource: CSV Reader`: Reads .csv files and provides their content according to the `io.openems.edge.simulator.datasource.api.SimulatorDatasource` interface. Its package contains several sample csv-files for different devices and situations.
* `Simulator EssSymmetric Reacting`: Simulates the State of Charge of a ess device. Its behavior depends on configured controllers.
* `Simulator GridMeter Acting`: Intended to represent grid consumption/production. Portrays a datasource' values. It requests those tagged with the "ActivePower" key. The values are portrayed in the `SimulatedActivePower`, `ActivePower` and - divided by three - in the `ActivePowerL1`, `ActivePowerL2` and `ActivePowerL3` channels.
* `Simulator ProductionMeter Acting`: Intended to represent fixed production like photovoltaic arrays. To date the functionality equals the one of `Simulator GridMeter Acting`.
* `Simulator NRCMeter Acting`: Intended to represent non-regulated-consumption. To date the functionality equals the one of `Simulator GridMeter Acting`.
* `Simulator GridMeter Reacting`: Intended to represent grid consumption/production. Takes all meters (but grid-meters) and esss, sums up their ActivePowers and divides this value by the number of grid-meters in the system. The negative of this result is then portrayed in the `SimulatedActivePower`, `ActivePower` and - divided by three - in the `ActivePowerL1`, `ActivePowerL2` and `ActivePowerL3` channels. This equals the physical reaction of the real grid.

=== Possible Combinations

In reality the OpenEMS can not measure the non-regulated-consumers, as they are spread all over the building. However, it can measure the power at the mains connection, which can be used to calculate the non-regulated-consumption. This approach can be simulated using the `Simulator GridMeter Acting` combined with a `Simulator EssSymmetric Reacting`.

For intelligent systems going beyond real-time-regulation, however, having a - even in production - virtual meter measuring the non-regulated-consumers can be a major advantage. In order to test algorithms depending on such an environment, the simulator provides the `Simulator ProductionMeter Acting`, the `Simulator NRCMeter Acting` and the `Simulator GridMeter Reacting`.